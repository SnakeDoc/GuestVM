/*
 * Copyright (c) 2010, 2011, Oracle and/or its affiliates. All rights reserved.
 * DO NOT ALTER OR REMOVE COPYRIGHT NOTICES OR THIS FILE HEADER.
 *
 * This code is free software; you can redistribute it and/or modify it
 * under the terms of the GNU General Public License version 2 only, as
 * published by the Free Software Foundation.
 *
 * This code is distributed in the hope that it will be useful, but WITHOUT
 * ANY WARRANTY; without even the implied warranty of MERCHANTABILITY or
 * FITNESS FOR A PARTICULAR PURPOSE.  See the GNU General Public License
 * version 2 for more details (a copy is included in the LICENSE file that
 * accompanied this code).
 *
 * You should have received a copy of the GNU General Public License version
 * 2 along with this work; if not, write to the Free Software Foundation,
 * Inc., 51 Franklin St, Fifth Floor, Boston, MA 02110-1301 USA.
 *
 * Please contact Oracle, 500 Oracle Parkway, Redwood Shores, CA 94065 USA
 * or visit www.oracle.com if you need additional information or have any
 * questions.
 */

/**
 *
 */
package com.sun.max.ve.tools;

import java.io.BufferedWriter;
import java.io.File;
import java.io.FileInputStream;
import java.io.FileWriter;
import java.io.FilenameFilter;
import java.util.ArrayList;
import java.util.HashMap;
import java.util.List;
import java.util.Map;
import java.util.Properties;
import java.util.Map.Entry;
import java.util.regex.Pattern;

import com.sun.max.ve.tools.ext2.Ext2FileTool;

/**
 * Generates a xen domain config file, a run script (that uses bin/run) and disk files for running Maxine VE based on the
 * properties file provided. Syntax of the properties file
 *
 * <pre>
 * disk1=<disk file path>
 * disk1.init=<true | false> #Create disk and copy JDK dirs and jars onto it.
 * disk1.mntpoint = <mount point in Maxine VE> #The run script if generated will contain the appropriate max.ve.fs.table string based on all disks and mount points
 * disk1.copypaths=<localpath:virtualdiskpath,localpath:virtualdiskpath> #specify files or directories to be copied onto the virtual disk.
 * disk1.size=<size of the disk in MB, defaults to 256m>
 * disk1.ro=<true|false> #should this be mounted as readonly. if false/null, defaults to auto
 * disk1.ext=<true|false> #Include extensions. Required for NfsServer
 * xenconfig=<the suffix of the xen domain config file.> #This file will be created in the directory ./xmconfigs/ with the name domain_config_suffix
 * xenconfig.initmem=<initial memory allocated to the Maxine VE domain. Defaults to 256>
 * xenconfig.maxmem=<Maximum memory allocated to the Maxine VE domain. Defaults to 1024>
 * xenconfig.net=<true|false> enable networking. Enabling means vif=['bridge=xenbro0'] will be generated if no bridge is specified using xenconfig.bridge
 * xenconfig.bridge=bridge to use for networking. xenconfig.net should be true, otherwise ignored
 * xenconfig.mac=Mac address to use for the network device. a default is generated by Maxine VE if not specified.
 * runscript=<the name of the run script file generated>
 *
 * <pre>
 * @author Puneeet Lakhina
 *
 */
public class ScratchPadGenerator {

    static class DiskImage {

        File _imageFile;
        boolean _init;
        String _mountpoint;
        String _maxveFsTableString;
        boolean _readOnly;
        String _frontEndDevice;
        Map<File, File> _copyPaths;
        boolean _includeExtensions;
        int _size;
    }

    static class XenConfig {

        String _fileSuffix;
        int _initMemory;
        int _maxMemory;
        boolean _networking;
        String _macAddress;
        String _vifBridge;
        List<DiskImage> _diskImageConfigs;
    }

    private static final String JAVA_HOME_PROPERTY = "JAVA_HOME";
    private static final String XEN_CONFIG_PROPERTY = "xenconfig";
    private static final String XEN_CONFIG_MAXMEM_PROPERTY = "xenconfig.maxmem";
    private static final String XEN_CONFIG_NETWORKING_PROPERTY = "xenconfig.net";
    private static final String XEN_CONFIG_BRIDGE_PROPERTY = "xenconfig.bridge";
    private static final String XEN_CONFIG_MAC_PROPERTY = "xenconfig.mac";
    private static final String XEN_CONFIG_INITMEM_PROPERTY = "xenconfig.initmem";
    private static final String DISK_CONFIG_PROPERTY_PREFIX = "disk";
    private static final String DISK_CONFIG_INIT_PROPERTY_SUFFIX = ".init";
    private static final String DISK_CONFIG_MOUNT_POINT_PROPERTY_SUFFIX = ".mntpoint";
    private static final String DISK_CONFIG_RO_PROPERTY_SUFFIX = ".ro";
    private static final String DISK_CONFIG_EXT_PROPERTY_SUFFIX = ".ext";
    private static final String DISK_CONFIG_SIZE_PROPERTY_SUFFIX = ".size";
    private static final String DISK_CONFIG_COPYPATHS_PROPERTY_SUFFIX = ".copypaths";
    private static final String RUNSCRIPT_FILE_NAME_PROPERTY = "runscript";
    private static final String FSTABLE_STRING_SEPARATOR = ";";

    private static final Pattern MAC_ADDRESS_PATTERN = Pattern.compile("^([0-9a-fA-F]{2}:){5}[0-9a-fA-F]{2}$");
    /**
     * @param args
     */
    public static void main(String[] args) throws Exception {
        final Properties p = new Properties();
        p.load(new FileInputStream(args[0]));
        boolean error = false;
        final String javaHome = System.getenv(JAVA_HOME_PROPERTY);
        if (javaHome == null) {
            System.err.println(JAVA_HOME_PROPERTY + " not defined");
            error = true;
        }
        final XenConfig config = new XenConfig();
        if (p.containsKey(XEN_CONFIG_PROPERTY)) {
            config._fileSuffix = p.getProperty(XEN_CONFIG_PROPERTY);
            if (p.containsKey(XEN_CONFIG_INITMEM_PROPERTY)) {
                config._initMemory = Integer.parseInt(p.getProperty(XEN_CONFIG_INITMEM_PROPERTY));
            } else {
                config._initMemory = 256;
            }
            config._networking = "true".equals(p.getProperty(XEN_CONFIG_NETWORKING_PROPERTY));
            if (config._networking) {
                config._vifBridge = p.getProperty(XEN_CONFIG_BRIDGE_PROPERTY) != null ? p.getProperty(XEN_CONFIG_BRIDGE_PROPERTY) : "xenbr0";
                config._macAddress = p.getProperty(XEN_CONFIG_MAC_PROPERTY) != null ? p.getProperty(XEN_CONFIG_MAC_PROPERTY) : null;
                if (config._macAddress != null && !MAC_ADDRESS_PATTERN.matcher(config._macAddress).matches()) {
                    System.err.println("Improper mac address:" + config._macAddress);
                    error = true;
                }
            }
            if (p.containsKey(XEN_CONFIG_MAXMEM_PROPERTY)) {
                config._maxMemory = Integer.parseInt(p.getProperty(XEN_CONFIG_MAXMEM_PROPERTY));
            } else {
                if (config._initMemory < 1024) {
                    config._maxMemory = 1024;
                } else {
                    config._maxMemory = config._initMemory + 256;
                }
            }
        } else {
            System.err.println("No Xen Config Specified");
            error = true;
        }
        final List<DiskImage> diskImageConfigs = new ArrayList<DiskImage>();
        config._diskImageConfigs = diskImageConfigs;
        // Disk Image operations
        for (int i = 1; i <= 5; i++) {
            final String propPrefix = DISK_CONFIG_PROPERTY_PREFIX + i;
            if (p.containsKey(DISK_CONFIG_PROPERTY_PREFIX + i)) {
                final File imageFile = new File(p.getProperty(propPrefix));
// if (!imageFile.exists()) {
// System.err.println("Image File:" + imageFile.getAbsolutePath() + " does not exist");
// error = true;
// }
                final DiskImage diskImage = new DiskImage();
                diskImage._imageFile = imageFile;
                diskImage._frontEndDevice = "sda" + i;
                diskImage._init = "true".equals(p.get(propPrefix + DISK_CONFIG_INIT_PROPERTY_SUFFIX));
                diskImage._includeExtensions = "true".equals(p.get(propPrefix + DISK_CONFIG_EXT_PROPERTY_SUFFIX));
                diskImage._mountpoint = p.getProperty(propPrefix + DISK_CONFIG_MOUNT_POINT_PROPERTY_SUFFIX);
                diskImage._readOnly = "true".equals(p.get(propPrefix + DISK_CONFIG_RO_PROPERTY_SUFFIX));
                try {
                    diskImage._size = Integer.parseInt(p.get(propPrefix + DISK_CONFIG_SIZE_PROPERTY_SUFFIX).toString());
                } catch (Exception e) {
                    diskImage._size = 256;
                }
                if (diskImage._mountpoint == null) {
                    System.err.println("A mount point must be specified for disk" + i);
                    error = true;
                }
                final Map<File, File> copyPaths = new HashMap<File, File>();
                if (p.containsKey(propPrefix + DISK_CONFIG_COPYPATHS_PROPERTY_SUFFIX)) {
                    final String[] copyDirsString = p.getProperty(propPrefix + DISK_CONFIG_COPYPATHS_PROPERTY_SUFFIX).split(",");
                    for (String pair : copyDirsString) {
                        final String[] fsgvPathPair = pair.split(":");
                        final File fileSystemPath = new File(fsgvPathPair[0]);
                        if (!fileSystemPath.exists()) {
                            System.err.println("File/Directory " + fileSystemPath + "doesnt exist");
                            error = true;
                        }
                        if ("".equals(fsgvPathPair[1])) {
                            System.err.println("Virtual Disk Image Path for " + fileSystemPath + " not Provided");
                            error = true;
                        }
                        copyPaths.put(fileSystemPath, new File(fsgvPathPair[1]));
                    }
                    diskImage._copyPaths = copyPaths;
                }
                diskImage._maxveFsTableString = String.format("ext2:/blk/%d:%s:%s", i - 1, diskImage._mountpoint, diskImage._readOnly ? "ro" : "auto");
                diskImageConfigs.add(diskImage);
            } else {
                break;
            }
        }
        if (diskImageConfigs.isEmpty()) {
            System.err.println("No Disk Images specified");
            error = true;
        }

        if (error) {
            System.err.println("Error occured. Exiting");
            return;
        }
        String maxveJavaHome = null;
        final StringBuilder fsString = new StringBuilder();
        String extBootClassPath = null;
        // Create Disk Image File.
        for (DiskImage diskImage : diskImageConfigs) {
            final String imageFilePath = diskImage._imageFile.getAbsolutePath();
            fsString.append(diskImage._maxveFsTableString + FSTABLE_STRING_SEPARATOR);
            if (diskImage._init) {

                System.out.println("Creating disk file:" + imageFilePath);
                diskImage._imageFile.delete();
                System.out.println(String.format("Creating disk of size: %dm",diskImage._size));
                Runtime.getRuntime().exec(String.format("mkfile %dm %s",diskImage._size,imageFilePath));
                Ext2FileTool.main(new String[] {"format", "-disk", imageFilePath});
                // Copy Java onto it.
                System.out.println("Copying JDK jars");
                final String ext2JavaHome = javaHome.substring(javaHome.lastIndexOf('/'));

                maxveJavaHome = diskImage._mountpoint + ext2JavaHome + "/jre";

                Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + ext2JavaHome).split("\\s"));
                Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + ext2JavaHome + "/lib").split("\\s"));
                Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + ext2JavaHome + "/jre").split("\\s"));
                Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + ext2JavaHome + "/jre/lib").split("\\s"));
                Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + ext2JavaHome + "/jre/bin").split("\\s"));
                Ext2FileTool.main(("mkfile -disk " + imageFilePath + " -ext2path " + ext2JavaHome + "/jre/bin/java").split("\\s"));
                Ext2FileTool.main(("copyin -disk " + imageFilePath + " -from " + javaHome + "/lib/tools.jar -ext2path " + ext2JavaHome + "/lib").split("\\s"));
                final String[] jreLibFiles = new String[] {"rt.jar", "jce.jar", "jsse.jar", "resources.jar", "charsets.jar", "management-agent.jar"};
                for (String jreLibFile : jreLibFiles) {
                    Ext2FileTool.main(("copyin -disk " + imageFilePath + " -from " + javaHome + "/jre/lib/" + jreLibFile + " -ext2path " + ext2JavaHome + "/jre/lib/" + jreLibFile).split("\\s"));
                }
                // Copy properties files.
                System.out.println("Copying JDK Properties files");
                for (String f : new File(javaHome + "/jre/lib/").list(new FilenameFilter() {

                    @Override
                    public boolean accept(File dir, String name) {
                        return name.endsWith(".properties");
                    }
                })) {
                    Ext2FileTool.main(("copyin -disk " + imageFilePath + " -from " + javaHome + "/jre/lib/" + f + " -ext2path " + ext2JavaHome + "/jre/lib/" + f).split("\\s"));
                }
                System.out.println("Copying JDK directories");
                final String[] copyDirectoryies = new String[] {"security", "zi", "management", "ext"};
                for (String copydirectory : copyDirectoryies) {
                    System.out.println("Copying: " + copydirectory);
                    Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + ext2JavaHome + "/jre/lib/" + copydirectory).split("\\s"));
                    Ext2FileTool.main(("copyin -r -disk " + imageFilePath + " -from " + javaHome + "/jre/lib/" + copydirectory + " -ext2path " + ext2JavaHome + "/jre/lib/" + copydirectory).split("\\s"));
                }
                if (diskImage._includeExtensions) {
                    if (diskImage._includeExtensions) {
                        extBootClassPath = diskImage._mountpoint + ext2JavaHome + "/ext/bin";
                    }
                    System.out.println("Copying Extensions");
                    Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + ext2JavaHome + "/ext").split("\\s"));
                    Ext2FileTool.main(("copyin -r -disk " + imageFilePath + " -from " + "../NfsServer/bin" + " -ext2path " + ext2JavaHome + "/ext").split("\\s"));
                }
            }

            System.out.println("Copying files if any");
            if (diskImage._copyPaths != null) {
                for (Entry<File, File> diskImageCopyPath : diskImage._copyPaths.entrySet()) {
                    System.out.println("Copying: " + diskImageCopyPath.getKey().getAbsolutePath());
                    if (diskImageCopyPath.getKey().isDirectory()) {
                        Ext2FileTool.main(("mkdir -disk " + imageFilePath + " -ext2path " + diskImageCopyPath.getValue()).split("\\s"));
                        Ext2FileTool.main(("copyin -r -disk " + imageFilePath + " -from " + diskImageCopyPath.getKey().getAbsolutePath() + " -ext2path " + diskImageCopyPath.getValue()).split("\\s"));
                    } else {
                        Ext2FileTool.main(("copyin -disk " + imageFilePath + " -from " + diskImageCopyPath.getKey().getAbsolutePath() + " -ext2path " + diskImageCopyPath.getValue()).split("\\s"));
                    }
                }
            }
        }
        System.out.println("Creating Xen Config");
        // Create Xen Config
        final StringBuilder builder = new StringBuilder("kernel= \"max.ve\"\n");
        builder.append("memory = \"" + config._initMemory + "\"\n");
        builder.append("maxmem = \"" + config._maxMemory + "\"\n");

        if (!diskImageConfigs.isEmpty()) {
            final StringBuilder diskStringBuilder = new StringBuilder("disk = [");
            for (DiskImage dic : diskImageConfigs) {
                diskStringBuilder.append("\"file:///" + dic._imageFile.getAbsolutePath() + "," + dic._frontEndDevice + ",w\",");
            }
            diskStringBuilder.setLength(diskStringBuilder.length() - 1);
            diskStringBuilder.append("]\n");
            builder.append(diskStringBuilder.toString());
        }
        if (config._networking) {
            builder.append(String.format("vif=['bridge=%s", config._vifBridge));
            if (config._macAddress != null) {
                builder.append(String.format(",mac=%s", config._macAddress));
            }
            builder.append("']\n");
        }
        builder.append("name = \"Maxine VE-\" + os.environ.get(\"USER\")\n");
        builder.append("on_crash = 'destroy'\n");
        System.out.println("Generating Xen Config");
        final FileWriter fw = new FileWriter("xmconfigs/domain_config_" + config._fileSuffix);
        fw.write(builder.toString());
        fw.close();

        System.out.println("Creating run script");
        // Create run script
        if (p.containsKey(RUNSCRIPT_FILE_NAME_PROPERTY)) {
            final File runScriptFile = new File(p.getProperty(RUNSCRIPT_FILE_NAME_PROPERTY));
            final BufferedWriter bw = new BufferedWriter(new FileWriter(runScriptFile));
            bw.write("#!/bin/bash\n");
            if (maxveJavaHome != null) {
                bw.write(String.format("javahomearg=\"-J-Djava.home=%s\"\n", maxveJavaHome));
                // bootclasspath
            }
            if (extBootClassPath != null) {
                bw.write(String.format("bootclasspath=\"-J-Xbootclasspath/p:%s\"\n", extBootClassPath));
            }
            if (!diskImageConfigs.isEmpty()) {
                fsString.setLength(fsString.length() - 1);
                bw.write(String.format("fstable=\"-J-Dmax.ve.fs.table=%s\"\n", fsString.toString()));
            }
            bw.write(String.format("./bin/run -cf %s $javahomearg $fstable $bootclasspath $*\n", config._fileSuffix));
            bw.close();
            runScriptFile.setExecutable(true);
        }
    }



}
